<!DOCTYPE html>

<html>

    <head>
        <meta charset="UTF-8">
        <title>Inteligência Artificial</title>
        <link rel="stylesheet"  href="latex.css" type="text/css">
    </head>

    <body>

        <header>
            <section>
                <!--<figure>
                    <img src="imagem/ai.jpeg" id ="imgLogo">
                </figure>-->
                <h1>Inteligência artificial: bot de reconhecimento de imagens</h1>
            </section>
        </header>

        <main>
            <section id="contato" class="abstract">
                <!--<figure>
                    <img src="imagem/casamentoFundo.jpg">
                </figure>-->
                
                <h2>Introdução</h2>
                <p>Neste trabalho construimos um bot que faz o reconhecimento de diversas imagens. O código foi feito em python e também foi disponibilizado como um bot no discord.</p>
            </section>
            <section>
                <p><strong>Resumo:</strong> A utilização de uma classificação de imagens com Deep Learning mostra-se muito
                    útil e eficiente, classificações como raça de cachorro podem ser modeladas e realizadas por
                    algorítimos eficientes. Por meio de um Data Set tornou-se possível realizar um aprendizado
                    onde pode-se classificar a raça de um cachorro, dentre 120 raças. Para interação com o
                    usuário, o Bot de classificação foi disponibilizado na plataforma Discord
                </p>
                <p>
                    <strong>Palavras-chave:</strong> Deep Learning, Data Set, classificação
                </p>
            
            </section>
            <section>
                <h2>1   Introdução</h2>
                <p>O presente trabalho tem o objetivo de mostrar de forma pratica, uma modelagem e implementação de
um código que utiliza da API Keras[Keras], para realizar um aprendizado de máquina, onde atravéz do
mesmo é capaz de classificar imagens e a partir desse vetor imagem, relacionar a uma raça.
                </p>
                <p>Foi utilizado um Data Set disponibilizado pelo Kaggle, onde por meio do mesmo, podemos criar
                    um modelo passível de aprendizado baseando-se nas relações coletadas dentro do Data Set. Realizado a
                    captura das informações, faz-se então necessário o treinamento do modelo para que o processo se torne
                    completo e por fim obtenha-se um classificador eficiente.
                </p>
                <p>
                    Observa-se que há nesse resultado diversas variáveis que influenciam o fluxo do sistema, como o
tempo de treinamento, as funções usadas, que serão apresentadas no desenvolvimento do trabalho.
                </p>
                
            </section>
            <section>
                <h2>2   Imports</h2>
                <p>Fizemos imports de algumas bibliotecas, sendo essas: numpy, pandas, tensorflow, os, matplotlib.pyplot, gc, seaborn e cv2.
                    Também pegamos algumas funções específicas de bibiliotecas, como por exemplo: do random importamos o randint, do tqdm importamos o próprio tqdm,
                    do subprocess importamos check_output, assim como outros que estarão listados logo abaixo juntos destes.
                </p>
                <ul>
                    <li>import numpy as np</li>
                    <li>import pandas as pd</li>
                    <li>import numpy as np</li>
                    <li>import tensorflow</li> 
                    <li>import os</li>
                    <li>import matplotlib.pyplot as plt</li>
                    <li>import gc</li>
                    <li>import seaborn as sns</li>
                    <li>import cv2</li>

                    <br>

                    <li>from random import randint</li>
                    <li>from tqdm import tqdm  </li>
                    <li>from subprocess import check_output</li>
                    <li>from sklearn.model_selection import train_test_split</li>
                    <li>from keras.optimizers import Adam, SGD</li>
                    <li>from keras.callbacks import ReduceLROnPlateau</li>
                    <li>from keras.layers import Flatten,Dense,BatchNormalization,Activation,Dropout</li>
                    <li>from keras.layers import Lambda, Input, GlobalAveragePooling2D,BatchNormalization
                    </li>
                    <li>from keras.utils import to_categorical
                    </li>
                    <li>from keras.models import Model
                    </li>
                    <li>from keras import models
                    </li>
                    <li>from keras import Sequential
                    </li>
                    <li>from keras.callbacks import EarlyStopping
                    </li>
                    <li>from tensorflow.keras.preprocessing.image import load_img
                    </li>
                    <li>from tensorflow.keras.preprocessing.image import img_to_array
                    </li>
                    <li>from keras.preprocessing import image
                    </li>
                    <li>from sklearn.preprocessing import label_binarize
                    </li>
                    <li>from sklearn.model_selection import train_test_split
                    </li>
                    <li>from keras import Sequential
                    </li>
                    <li>from keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D
                    </li>
                    <li>from keras.optimizers import Adam</li>
                    
                </ul>
 
            </section>
            <section>
                <h2>3   Preparação dos dados</h2>
                <p>Nesta parte, mostramos uma parte de código da qual vizualiza as classes dos cachorros disponíveis.
                    Encontramos a contagem por cada classe, isto é, o total de dados em cada classe usando value_counts()
                </p>
                <p>
                    <em>
                        breeds_all = df_train["breed"]
                        <br>breed_counts = breeds_all.value_counts()
                        <br>breed_counts.head(120)
                    </em>
                </p>
                <p>
                    Aqui carregamos as imagens do treino.
                </p>
                <p>
                    <em>
                        mg_width=250
                        <br>img_height=250
                        <br>images=[]
                        <br>classes=[]
                        <br>
                        <br>
                        <strong>#carrega as imagens em treinamento</strong>
                        <br>for f, breed in tqdm(df_train.values):
                        <br>&emsp;img = cv2.imread(caminho + 'train/{}.jpg'.format(f))
                        <br>&emsp;classes.append(breed)
                        <br>&emsp;images.append(cv2.resize(img, (img_width, img_height)))
                    </em>
                </p>
                
            </section>
            <section>
                <h2>4   Modelo e Treinamento</h2>
                <p>
                    Primeiramente, para podermos efetivamente classificar as imagens, pegamos um conjunto prévio de imagens classificadas
                    para que o modelo pudesse ser treinado e calibrado. Para que o modelo conseguisse generalizar a classificação, foi necessário um enorme conjunto
                    de dados de cada uma das categorias do modelo.
                </p>
                <br>
                <p>
                    Seguindo para o Treinamento, ainda temos diversas funções para que ele possa ocorrer corretamente. Que são as seguintes:
                    <ui>
                        <li><strong>Gráfico de imagem:</strong></li>
                        <p><em>
                            <strong>def plot_images(images, classes):</strong>
                            <br>&ensp;assert len(images) == len(classes) == 9
                            
                            <br>&ensp;<strong># Cria uma imagem com sub-plots 3x3 .</strong>
                            <br>&ensp;fig, axes = plt.subplots(3, 3,figsize=(60,60),sharex=True)
                            <br>&ensp;fig.subplots_adjust(hspace=0.3, wspace=0.3)
                        
                            <br><br>&ensp;for i, ax in enumerate(axes.flat):
                            <br>&emsp;<strong># Faz o gráfico da imagem.</strong>
                                
                            <br>&emsp;ax.imshow(cv2.cvtColor(images[i],cv2.COLOR_BGR2RGB).reshape(img_width,img_height,3), cmap='hsv')    
                            <br>&emsp;xlabel = "Breed: {0}".format(classes[i])
                            
                            <br><br>&emsp;<strong># Mostra classes como label no eixo X.</strong>
                            <br>&emsp;ax.set_xlabel(xlabel)
                            <br>&emsp;ax.xaxis.label.set_size(60)

                            <br><br>&emsp;<strong># Remove os ticks do gráfico.</strong>
                            <br>&emsp;ax.set_xticks([])
                            <br>&emsp;ax.set_yticks([])
                            
                            <br>&ensp;<strong># Garante de que o gráfico seja mostrado corretamente com vários gráficos em apenas uma célula.</strong>

                            <br>&ensp;plt.show()
                        </em></p>

                        <br><br><li><strong>Seleção e plot de imagens:</strong></li>
                        <p><em>
                            <strong># seleciona imagens aleatórias</strong>
                            <br>random_numbers = [randint(0, len(images)) for p in range(9,18)]
                            <br>print(random_numbers)
                            <br>images_to_show = [images[i] for i in random_numbers]
                            <br>classes_to_show = [classes[i] for i in random_numbers]
                            <br>print("Images to show: {0}".format(len(images_to_show)))
                            <br>print("Classes to show: {0}".format(len(classes_to_show)))

                            
                            <br><br><strong>#plota as imagens</strong>
                            <br>plot_images(images_to_show, classes_to_show)

                        </em></p>

                        <br><br><li><strong>Conversão dos dados da imagem para numpy array:</strong></li>
                        <p><em>
                            <strong># Cria matrix numpy com vários zeros</strong>
                            <br>X_data = np.zeros((len(labels), 28, 28, 3), dtype='float32')
                            <br>Y_data = label_binarize(labels['breed'], classes = CLASS_NAMES)

                            <br><br><strong># Lendo e convertendo imagem para numpy array e normalizando os dados</strong>
                            <br>for i in tqdm(range(len(labels))):
                            <br>&emsp;img = load_img(caminho + 'train/%s.jpg' % labels['id'][i], target_size=(28, 28))
                            <br>&emsp;img = img_to_array(img)
                            <br>&emsp;x = np.expand_dims(img.copy(), axis=0)
                            <br>&emsp;X_data[i] = x / 255.0

                            <br><strong># Imprimindo a imagem</strong>
                            <br>print('\nTrain Images shape: ',X_data.shape,' size: {:,}'.format(X_data.size))
                            <br>print('One-hot encoded output shape: ',Y_data.shape,' size: {:,}'.format(Y_data.size))

                        </em></p>

                        <br><br><li><strong>Construção do modelo:</strong></li>
                        <p><em>
                            <strong># Construindo o Model</strong>
                            <br>model = Sequential()
                            <br>model.add(Conv2D(filters = 64, kernel_size = (5,5), activation ='softmax', input_shape = (28,28,3)))
                            <br>model.add(MaxPool2D(pool_size=(5,5)))

                            <br><br>model.add(Flatten())
                            <br>model.add(Dense(128, activation = "softmax"))
                            <br>model.add(Dense(64, activation = "softmax"))
                            <br>model.add(Dense(len(CLASS_NAMES), activation = "softmax"))

                            <br><br>model.compile(loss = 'mean_squared_error', optimizer = Adam(0.0001),metrics=['accuracy'])

                            <br><br>model.summary()

                        </em></p>

                        <br><br><li><strong>Repartir os dados:</strong></li>
                        <p><em>
                            <strong># Repartindo os dados em dados de treinamento e teste</strong>
                            <br>X_train_and_val, X_test, Y_train_and_val, Y_test = train_test_split(X_data, Y_data, test_size = 0.001)

                            <br><br><strong># Repartindo os dados de treinamento em dados de treinamento e validação</strong>
                            <br>X_train, X_val, Y_train, Y_val = train_test_split(X_train_and_val, Y_train_and_val, test_size = 0.002)

                        </em></p>

                        <br><br><li><strong>Treinando o modelo:</strong></li>
                        <p><em>
                            <strong># Treinando o modelo</strong>
                            <br>epochs = 15
                            <br>batch_size = 128
                            
                            <br><br>history = model.fit(X_train, Y_train, batch_size = batch_size, epochs = epochs, 
                                                validation_data = (X_val, Y_val))

                            <br><br><strong># Nesta parte o código calcula a precisão de acerto do teste</strong>

                            <br>Y_pred = model.predict(X_test)
                            <br>score = model.evaluate(X_test, Y_test)
                            <br>print('Accuracy over the test set: \n ', round((score[1]*100), 2), '%')

                            <br><br><strong># Salva o modelo</strong>
                            <br>model.save('modelodog3.h5') #salvar o modelo usado para o bot

                            <br><br><strong># Carrega o modelo</strong>
                            <br>model = models.load_model('modelodog3.h5')

                        </em></p>

                        <br><br><li><strong>Reconhecendo enfim da imagem:</strong></li>
                        <p><em>
                            <strong>import</strong> cv2
                            <br><strong># Caminho da imagem</strong>
                            <br>path = caminho + 'cachorroTeste.jpg'
                            
                            <br><br><strong># Nome da janela que a imagem é mostrada</strong>
                            <br>window_name = 'batata'

                            <br><br><strong># Usando o método cv2.imshow()</strong>
                            <br><strong># Mostrando imagem</strong>
                            <br>cv2.imshow(window_name, image)

                            <br><br><strong># Espera o usuário apertar qualquer tecla (isso é necessário para evitar o travamento do formulário do kernel do Python).</strong>
                            <br>cv2.waitKey(0)

                            <br><br><strong># Fecha todas as janelas abertas</strong>
                            <br>cv2.destroyAllWindows()

                            <br><br><strong># Plota a imagem</strong>
                            <br>plt.imshow(img)
                            <br>plt.show()

                            <br><br><strong> # Pegando o maior valor da lista de predição e comparando o original com a predição</strong>
                            <br>print("Originally : ",labels['breed'][np.argmax(Y_test[0])])
                            <br>print("Predicted : ",labels['breed'][np.argmax(Y_pred[0])])


                        </em></p>
                    </ui>
                </p>
                <p>
                <strong>Considerações:</strong>
                </p>

                <ui>
                    <li>Usar softmax é melhor do que usar relo. Softmax nos retorna mais parametros de treino</li>
                    <li>categorical_crossentropy aumenta o loss</li>
                    <li>mean_squared_error deixa o loss bem baixo. Diminui de 7,xxx para 2,xxxx</li>
                </ui>
            </section>

            <section>
                <h2>5  Conclusão</h2>
                <p>Conseguimos fazer o programa a guardar os padrões através da análise dos pixels das imagens já pré-definidas.
                    Pegamos as imagens e convertemos todos os dados dos pixels para formato de array.
                    Nisso criamos os modelos que vão guardando os padrões de diversas imagens à serem reconhecidas, gerando então o aprendizado em si.
                    Como resultado obtivemos sucesso e a imagem que foi selecionada foi reconhecida pelo programa, mesmo não tendo exatamente 100% de precisão.
                </p>
            </section>
        </main>
        
        <footer>
            <section style="margin-top: 0;">
                <h5 style="top: 120px;">Integrantes: Lucas Carvalho, Thaysa, Daniel McCarthy e Lorenzo Canelhas</h5>
            </section>

        </footer>
    </body>

</html>